{"version":3,"file":"index.js","sources":["webpack://vue-tiny-slider/webpack/universalModuleDefinition","webpack://vue-tiny-slider/./node_modules/vue-removed-hook-mixin/dist/vue-removed-hook-mixin.esm.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"vue-tiny-slider\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"vue-tiny-slider\"] = factory();\n\telse\n\t\troot[\"vue-tiny-slider\"] = factory();\n})(window, function() {\nreturn ","/*!\n  * vue-removed-hook-mixin v0.1.0\n  * (c) 2019 James Diacono\n  * @license MIT\n  */\n// adds a 'removed' hook to the component, which fires once the component\n// is fully removed from the DOM\nvar index = {\n  destroyed: function destroyed() {\n    var this$1 = this;\n\n    var removed = function () {\n      // quick and dirty version of Vue's lifecycle callHook method\n      this$1.$options.removed.call(this$1);\n    };\n\n    // element was immediately detached from DOM (no transition)\n    if (!document.body.contains(this.$el)) {\n      removed();\n      return\n    }\n\n    var mutationHandler = function (mutations, observer) {\n      for (var i = 0; i < mutations.length; i++) {\n        var ref = mutations[i];\n        var removedNodes = ref.removedNodes;\n\n        for (var j = 0; j < removedNodes.length; j++) {\n          if (removedNodes[j].contains(this$1.$el)) {\n            observer.disconnect();\n            removed();\n          }\n        }\n      }\n    };\n\n    // start observing parent element for changes to the DOM\n    var observer = new MutationObserver(mutationHandler);\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n  },\n}\n\nexport default index;\n"],"mappings":"AAAA;;;;;;ACOA","sourceRoot":""}